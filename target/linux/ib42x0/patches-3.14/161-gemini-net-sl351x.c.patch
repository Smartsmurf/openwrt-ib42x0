--- a/drivers/net/ethernet/gemini/sl351x.c
+++ b/drivers/net/ethernet/gemini/sl351x.c
@@ -0,0 +1,2219 @@
+/*
+ *  Ethernet device driver for Gemini SoC (SL351x GMAC).
+ *
+ *  Copyright (C) 2014, Tobias Waldvogel <tobias.waldvogel@gmail.com>
+ *
+ *  Based on work by Michał Mirosław <mirq-linux@rere.qmqm.pl> and
+ *  Paulius Zaleckas <paulius.zaleckas@gmail.com> and
+ *  Giuseppe De Robertis <Giuseppe.DeRobertis@ba.infn.it> and
+ *  GPLd spaghetti code from Raidsonic and other Gemini-based NAS vendors.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/cache.h>
+#include <linux/interrupt.h>
+
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/crc32.h>
+#include <linux/ethtool.h>
+#include <linux/tcp.h>
+#include <linux/u64_stats_sync.h>
+
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+
+#include <mach/hardware.h>
+#include <mach/global_reg.h>
+
+#include <linux/platform_data/sl351x.h>
+#include "sl351x_hw.h"
+
+#define DRV_NAME		"sl351x"
+#define DRV_VERSION		"1.0"
+
+#define HSIZE_8			0b00
+#define HSIZE_16		0b01
+#define HSIZE_32		0b10
+
+#define HBURST_SINGLE		0b00
+#define HBURST_INCR		0b01
+#define HBURST_INCR4		0b10
+#define HBURST_INCR8		0b11
+
+#define HPROT_DATA_CACHE	BIT(0)
+#define HPROT_PRIVILIGED	BIT(1)
+#define HPROT_BUFFERABLE	BIT(2)
+#define HPROT_CACHABLE		BIT(3)
+
+#define DEFAULT_RX_COALESCE_NSECS	0
+#define DEFAULT_GMAC_RXQ_ORDER		9
+#define DEFAULT_GMAC_TXQ_ORDER		8
+#define DEFAULT_RX_BUF_ORDER		11
+#define DEFAULT_NAPI_WEIGHT		64
+#define TX_MAX_FRAGS			16
+#define TX_QUEUE_NUM			1	/* max: 6 */
+#define RX_MAX_ALLOC_ORDER		2
+
+#define GMAC0_IRQ0_2 (GMAC0_TXDERR_INT_BIT|GMAC0_TXPERR_INT_BIT| \
+	GMAC0_RXDERR_INT_BIT|GMAC0_RXPERR_INT_BIT)
+#define GMAC0_IRQ0_TXQ0_INTS (GMAC0_SWTQ00_EOF_INT_BIT| \
+			      GMAC0_SWTQ00_FIN_INT_BIT)
+#define GMAC0_IRQ4_8 (GMAC0_MIB_INT_BIT|GMAC0_RX_OVERRUN_INT_BIT)
+
+#define GMAC_OFFLOAD_FEATURES (NETIF_F_SG | NETIF_F_IP_CSUM | \
+		NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM | \
+		NETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6)
+
+MODULE_AUTHOR("Tobias Waldvogel");
+MODULE_DESCRIPTION("StorLink SL351x (Gemini) ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+struct toe_private {
+	void __iomem	*iomem;
+	spinlock_t	irq_lock;
+
+	struct net_device *netdev[2];
+	__le32		mac_addr[2][3];
+
+	struct device	*dev;
+	int		irq;
+
+	unsigned int	freeq_order;
+	unsigned int	freeq_frag_order;
+	GMAC_RXDESC_T	*freeq_ring;
+	dma_addr_t	freeq_dma_base;
+	struct page	**freeq_page_tab;
+	spinlock_t	freeq_lock;
+	u64		freeq_replaced;
+};
+
+struct sl351x_txq {
+	GMAC_TXDESC_T	*ring;
+	struct sk_buff	**skb;
+	unsigned int	cptr;
+	unsigned int	noirq_packets;
+};
+
+struct sl351x_private {
+	unsigned int		num;
+	struct toe_private	*toe;
+	void __iomem		*ctl_iomem;
+	void __iomem		*dma_iomem;
+
+	void __iomem		*rxq_rwptr;
+	GMAC_RXDESC_T		*rxq_ring;
+	unsigned int		rxq_order;
+
+	struct napi_struct	napi;
+	struct hrtimer		rx_coalesce_timer;
+	unsigned int 		rx_coalesce_nsecs; 
+	unsigned int		freeq_refill;
+	struct sl351x_txq		txq[TX_QUEUE_NUM];
+	unsigned int		txq_order;
+	unsigned int		irq_every_tx_packets;
+
+	dma_addr_t		rxq_dma_base;
+	dma_addr_t		txq_dma_base;
+
+	unsigned int		msg_enable;
+	spinlock_t		config_lock;
+
+	struct u64_stats_sync	tx_stats_syncp;
+	struct u64_stats_sync	rx_stats_syncp;
+	struct u64_stats_sync	ir_stats_syncp;
+
+	struct rtnl_link_stats64 stats;
+	u64			hw_stats[RX_STATS_NUM];
+	u64			rx_stats[RX_STATUS_NUM];
+	u64			rx_csum_stats[RX_CHKSUM_NUM];
+	u64			rx_napi_exits;
+	u64			tx_frag_stats[TX_MAX_FRAGS];
+	u64			tx_frags_linearized;
+	u64			tx_hw_csummed;
+};
+
+#define GMAC_STATS_NUM	( \
+	RX_STATS_NUM + RX_STATUS_NUM + RX_CHKSUM_NUM + 1 + \
+	TX_MAX_FRAGS + 2)
+
+static const char sl351x_stats_strings[GMAC_STATS_NUM][ETH_GSTRING_LEN] = {
+	"GMAC_IN_DISCARDS",
+	"GMAC_IN_ERRORS",
+	"GMAC_IN_MCAST",
+	"GMAC_IN_BCAST",
+	"GMAC_IN_MAC1",
+	"GMAC_IN_MAC2",
+	"RX_STATUS_GOOD_FRAME",
+	"RX_STATUS_TOO_LONG_GOOD_CRC",
+	"RX_STATUS_RUNT_FRAME",
+	"RX_STATUS_SFD_NOT_FOUND",
+	"RX_STATUS_CRC_ERROR",
+	"RX_STATUS_TOO_LONG_BAD_CRC",
+	"RX_STATUS_ALIGNMENT_ERROR",
+	"RX_STATUS_TOO_LONG_BAD_ALIGN",
+	"RX_STATUS_RX_ERR",
+	"RX_STATUS_DA_FILTERED",
+	"RX_STATUS_BUFFER_FULL",
+	"RX_STATUS_11",
+	"RX_STATUS_12",
+	"RX_STATUS_13",
+	"RX_STATUS_14",
+	"RX_STATUS_15",
+	"RX_CHKSUM_IP_UDP_TCP_OK",
+	"RX_CHKSUM_IP_OK_ONLY",
+	"RX_CHKSUM_NONE",
+	"RX_CHKSUM_3",
+	"RX_CHKSUM_IP_ERR_UNKNOWN",
+	"RX_CHKSUM_IP_ERR",
+	"RX_CHKSUM_TCP_UDP_ERR",
+	"RX_CHKSUM_7",
+	"RX_NAPI_EXITS",
+	"TX_FRAGS[1]",
+	"TX_FRAGS[2]",
+	"TX_FRAGS[3]",
+	"TX_FRAGS[4]",
+	"TX_FRAGS[5]",
+	"TX_FRAGS[6]",
+	"TX_FRAGS[7]",
+	"TX_FRAGS[8]",
+	"TX_FRAGS[9]",
+	"TX_FRAGS[10]",
+	"TX_FRAGS[11]",
+	"TX_FRAGS[12]",
+	"TX_FRAGS[13]",
+	"TX_FRAGS[14]",
+	"TX_FRAGS[15]",
+	"TX_FRAGS[16+]",
+	"TX_FRAGS_LINEARIZED",
+	"TX_HW_CSUMMED",
+	"FREEQ_REPLACED",
+};
+
+static void sl351x_set_txrx(struct net_device *dev, bool enable)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	void __iomem *config0 = priv->ctl_iomem + GMAC_CONFIG0;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&priv->config_lock, flags);
+	reg = readl(config0);
+	reg = enable ? reg & ~CONFIG0_TX_RX_DISABLE :
+		       reg | CONFIG0_TX_RX_DISABLE;
+	writel(reg, config0);
+	spin_unlock_irqrestore(&priv->config_lock, flags);
+
+	if (!enable)
+		mdelay(10);
+}
+
+static void sl351x_set_flow_control(struct net_device *dev, bool tx, bool rx)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	void __iomem *config0 = priv->ctl_iomem + GMAC_CONFIG0;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&priv->config_lock, flags);
+	reg = readl(config0);
+	reg &= ~CONFIG0_FLOW_CTL;
+	if (tx)
+		reg |= CONFIG0_FLOW_TX;
+	if (rx)
+		reg |= CONFIG0_FLOW_RX;
+	writel(reg, config0);
+	spin_unlock_irqrestore(&priv->config_lock, flags);
+}
+
+ static const char *phy_speed_to_str(int speed)
+ {
+ 	switch (speed) {
+ 	case SPEED_10:
+ 		return "10Mbps";
+ 	case SPEED_100:
+ 		return "100Mbps";
+ 	case SPEED_1000:
+ 		return "1Gbps";
+ 	case SPEED_2500:
+ 		return "2.5Gbps";
+ 	case SPEED_10000:
+ 		return "10Gbps";
+ 	case SPEED_UNKNOWN:
+ 		return "Unknown";
+ 	default:
+ 		return "Unsupported (update phy.c)";
+ 	}
+ }
+
+/**
+ * Advanced from kernel 3.16
+ * phy_print_status - Convenience function to print out the current phy status
+ * @phydev: the phy_device struct
+ */
+ void __phy_print_status(struct phy_device *phydev)
+ {
+ 	if (phydev->link) {
+ 		netdev_info(phydev->attached_dev,
+ 			    "Link is Up - %s/%s - flow control %s\n",
+ 			    phy_speed_to_str(phydev->speed),
+ 			    DUPLEX_FULL == phydev->duplex ? "Full" : "Half",
+ 			    phydev->pause ? "rx/tx" : "off");
+ 	} else  {
+ 		netdev_info(phydev->attached_dev, "Link is Down\n");
+ 	}
+ }
+ 
+static void sl351x_update_link_state(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	void __iomem *status_reg = priv->ctl_iomem + GMAC_STATUS;
+	struct phy_device *phydev = dev->phydev;
+	GMAC_STATUS_T status, old_status;
+	int pause_tx=0, pause_rx=0;
+
+	old_status.bits32 = status.bits32 = readl(status_reg);
+
+	status.bits.link = phydev->link;
+	status.bits.duplex = phydev->duplex;
+
+	switch (phydev->speed) {
+	case 1000:
+		status.bits.speed = GMAC_SPEED_1000;
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII)
+			status.bits.mii_rmii = GMAC_PHY_RGMII_1000;
+		break;
+	case 100:
+		status.bits.speed = GMAC_SPEED_100;
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII)
+			status.bits.mii_rmii = GMAC_PHY_RGMII_100_10;
+		break;
+	case 10:
+		status.bits.speed = GMAC_SPEED_10;
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII)
+			status.bits.mii_rmii = GMAC_PHY_RGMII_100_10;
+		break;
+	default:
+		netif_warn(priv, link, dev, "Unsupported PHY speed (%d)\n",
+			phydev->speed);
+	}
+
+	if (phydev->duplex == DUPLEX_FULL) {
+		u16 lcladv = phy_read(phydev, MII_ADVERTISE);
+		u16 rmtadv = phy_read(phydev, MII_LPA);
+		u8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
+
+		if (cap & FLOW_CTRL_RX)
+			pause_rx=1;
+		if (cap & FLOW_CTRL_TX)
+			pause_tx=1;
+	} 
+
+	sl351x_set_flow_control(dev, pause_tx, pause_rx);
+
+	if (old_status.bits32 == status.bits32)
+		return;
+
+	if (status.bits.link || old_status.bits.link)
+		if (netif_msg_link(priv))
+			__phy_print_status(phydev);
+
+	sl351x_set_txrx(dev, 0);
+	writel(status.bits32, status_reg);
+	sl351x_set_txrx(dev, 1);
+}
+
+static int sl351x_setup_phy(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	struct sl351x_platform_data *pdata = toe->dev->platform_data;
+	GMAC_STATUS_T status = { .bits32 = 0 };
+	int num = dev->dev_id;
+
+	dev->phydev = phy_connect(dev, pdata->bus_id[num],
+		&sl351x_update_link_state, pdata->interface[num]);
+
+	if (IS_ERR(dev->phydev)) {
+		int err = PTR_ERR(dev->phydev);
+		dev->phydev = NULL;
+		return err;
+	}
+
+	dev->phydev->supported &= PHY_GBIT_FEATURES;
+	dev->phydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;
+	dev->phydev->advertising = dev->phydev->supported;
+
+	/* set PHY interface type */
+	switch (dev->phydev->interface) {
+	case PHY_INTERFACE_MODE_MII:
+		status.bits.mii_rmii = GMAC_PHY_MII;
+		break;
+	case PHY_INTERFACE_MODE_GMII:
+		status.bits.mii_rmii = GMAC_PHY_GMII;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		status.bits.mii_rmii = GMAC_PHY_RGMII_100_10;
+		break;
+	default:
+		netif_err(priv, probe, dev, "Unsupported MII interface\n");
+		phy_disconnect(dev->phydev);
+		dev->phydev = NULL;
+		return -EINVAL;
+	}
+	writel(status.bits32, priv->ctl_iomem + GMAC_STATUS);
+
+	return 0;
+}
+
+static int sl351x_pick_rx_max_len(int max_l3_len)
+{
+	/* index = CONFIG_MAXLEN_XXX values */
+	static const int max_len[8] = {
+		1536, 1518, 1522, 1542,
+		9212, 10236, 1518, 1518
+	};
+	int i, n = 5;
+
+	max_l3_len += ETH_HLEN + VLAN_HLEN;
+
+	if (max_l3_len > max_len[n])
+		return -1;
+
+	for (i = 0; i < 5; ++i)
+		if (max_len[i] >= max_l3_len && max_len[i] < max_len[n])
+			n = i;
+
+	return n;
+}
+
+static int sl351x_hw_init(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	u32 val;
+
+	GMAC_CONFIG0_T config0 = { .bits = {
+		.dis_tx = 1,
+		.dis_rx = 1,
+		.ipv4_rx_chksum = 1,
+		.ipv6_rx_chksum = 1,
+		.rx_err_detect = 1,
+		.rgmm_edge = 1,
+		.port0_chk_hwq = 1,
+		.port1_chk_hwq = 1,
+		.port0_chk_toeq = 1,
+		.port1_chk_toeq = 1,
+		.port0_chk_classq = 1,
+		.port1_chk_classq = 1,
+	} };
+	GMAC_AHB_WEIGHT_T ahb_weight = { .bits = {
+		.rx_weight = 1,
+		.tx_weight = 1,
+		.hash_weight = 1,
+		.pre_req = 0x1f,
+		.tqDV_threshold = 0,
+	} };
+	GMAC_TX_WCR0_T hw_weigh = { .bits = {
+		.hw_tq3 = 1,
+		.hw_tq2 = 1,
+		.hw_tq1 = 1,
+		.hw_tq0 = 1,
+	} };
+	GMAC_TX_WCR1_T sw_weigh = { .bits = {
+		.sw_tq5 = 1,
+		.sw_tq4 = 1,
+		.sw_tq3 = 1,
+		.sw_tq2 = 1,
+		.sw_tq1 = 1,
+		.sw_tq0 = 1,
+	} };
+	GMAC_CONFIG1_T config1 = { .bits = {
+		.set_threshold = 16,
+		.rel_threshold = 24,
+	} };
+	GMAC_CONFIG2_T config2 = { .bits = {
+		.set_threshold = 16,
+		.rel_threshold = 32,
+	} };
+	GMAC_CONFIG3_T config3 = { .bits = {
+		.set_threshold = 0,
+		.rel_threshold = 0,
+	} };
+
+	config0.bits.max_len = sl351x_pick_rx_max_len(dev->mtu);
+
+	val = readl(priv->ctl_iomem + GMAC_CONFIG0);
+	config0.bits.reserved = ((GMAC_CONFIG0_T)val).bits.reserved;
+	writel(config0.bits32, priv->ctl_iomem + GMAC_CONFIG0);
+	writel(config1.bits32, priv->ctl_iomem + GMAC_CONFIG1);
+	writel(config2.bits32, priv->ctl_iomem + GMAC_CONFIG2);
+	writel(config3.bits32, priv->ctl_iomem + GMAC_CONFIG3);
+
+	val = readl(priv->dma_iomem + GMAC_AHB_WEIGHT_REG);
+	writel(ahb_weight.bits32, priv->dma_iomem + GMAC_AHB_WEIGHT_REG);
+
+	writel(hw_weigh.bits32,
+		priv->dma_iomem + GMAC_TX_WEIGHTING_CTRL_0_REG);
+	writel(sw_weigh.bits32,
+		priv->dma_iomem + GMAC_TX_WEIGHTING_CTRL_1_REG);
+
+	priv->rxq_order = DEFAULT_GMAC_RXQ_ORDER;
+	priv->txq_order = DEFAULT_GMAC_TXQ_ORDER;
+	priv->rx_coalesce_nsecs = DEFAULT_RX_COALESCE_NSECS;
+
+	/* Mark every quarter of the queue a packet for interrupt
+	   in order to be able to wake up the queue if it was stopped */
+	priv->irq_every_tx_packets = 1 << (priv->txq_order - 2);
+	return 0;
+}
+
+static void sl351x_hw_uninit(struct net_device *dev)
+{
+}
+
+static int sl351x_setup_txqs(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	void __iomem *rwptr_reg = priv->dma_iomem + GMAC_SW_TX_QUEUE0_PTR_REG;
+	void __iomem *base_reg = priv->dma_iomem + GMAC_SW_TX_QUEUE_BASE_REG;
+
+	unsigned int n_txq = dev->num_tx_queues;
+	size_t entries = 1 <<priv->txq_order;
+	size_t len = n_txq * entries;
+	struct sl351x_txq *txq = priv->txq;
+	GMAC_TXDESC_T *desc_ring;
+	struct sk_buff **skb_tab;
+	unsigned int r;
+	int i;
+
+	skb_tab = kzalloc(len * sizeof(*skb_tab), GFP_KERNEL);
+	if (!skb_tab)
+		return -ENOMEM;
+
+	desc_ring = dma_alloc_coherent(toe->dev, len * sizeof(*desc_ring),
+		&priv->txq_dma_base, GFP_KERNEL);
+
+	if (!desc_ring) {
+		kfree(skb_tab);
+		return -ENOMEM;
+	}
+
+	BUG_ON(priv->txq_dma_base & ~DMA_Q_BASE_MASK);
+
+	writel(priv->txq_dma_base | priv->txq_order, base_reg);
+
+	for (i = 0; i < n_txq; i++) {
+		txq->ring = desc_ring;
+		txq->skb = skb_tab;
+		txq->noirq_packets = 0;
+
+		r = readw(rwptr_reg);
+		rwptr_reg += 2;
+		writew(r, rwptr_reg);
+		rwptr_reg +=2;
+		txq->cptr = r;
+		
+		txq++;
+		desc_ring += entries;
+		skb_tab += entries;
+	}
+
+	return 0;
+}
+
+static void sl351x_clean_txq(struct net_device *dev, struct sl351x_txq *txq,
+			   unsigned int r)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned int errs = 0;
+	unsigned int pkts = 0;
+	unsigned int hwchksum = 0;
+	unsigned long bytes = 0;
+	unsigned int m = (1 << priv->txq_order) - 1;
+	unsigned int c = txq->cptr;
+	GMAC_TXDESC_0_T word0;
+	GMAC_TXDESC_1_T word1;
+	unsigned int word3;
+	dma_addr_t dma;
+	GMAC_TXDESC_T *txd;
+	unsigned short nfrags;
+
+	if (unlikely(c == r))
+		return;
+
+	rmb();
+	while (c != r) {
+		txd = txq->ring + c;
+		word0 = txd->word0;
+		word1 = txd->word1;
+		dma = txd->word2.buf_adr;
+		word3 = txd->word3.bits32;
+
+		dma_unmap_single(toe->dev, dma, word0.bits.buffer_size, DMA_TO_DEVICE);
+
+		if (word3 & EOF_BIT)
+			dev_kfree_skb(txq->skb[c]);
+
+		c++;
+		c &= m;
+
+		if (!(word3 & SOF_BIT))
+			continue;
+		
+		if (!word0.bits.status_tx_ok) {
+			errs++;
+			continue;
+		}
+
+		pkts++;
+		bytes += txd->word1.bits.byte_count;
+
+		if (word1.bits32 & TSS_CHECKUM_ENABLE)
+			hwchksum++;
+
+		nfrags = word0.bits.desc_count - 1;
+		if (nfrags) {
+			if (nfrags >= TX_MAX_FRAGS)
+				nfrags = TX_MAX_FRAGS - 1;
+
+			u64_stats_update_begin(&priv->tx_stats_syncp);
+			priv->tx_frag_stats[nfrags]++;
+			u64_stats_update_end(&priv->ir_stats_syncp);
+		}
+	}
+
+	u64_stats_update_begin(&priv->ir_stats_syncp);
+	priv->stats.tx_errors += errs;
+	priv->stats.tx_packets += pkts;
+	priv->stats.tx_bytes += bytes;
+	priv->tx_hw_csummed += hwchksum;
+	u64_stats_update_end(&priv->ir_stats_syncp);
+
+	txq->cptr = c;
+}
+
+static void sl351x_cleanup_txqs(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	void __iomem *rwptr_reg = priv->dma_iomem + GMAC_SW_TX_QUEUE0_PTR_REG;
+	void __iomem *base_reg = priv->dma_iomem + GMAC_SW_TX_QUEUE_BASE_REG;
+
+	unsigned n_txq = dev->num_tx_queues;
+	unsigned int r, i;
+
+	for (i = 0; i < n_txq; i++) {
+		r = readw(rwptr_reg);
+		rwptr_reg += 2;
+		writew(r, rwptr_reg);
+		rwptr_reg += 2;
+
+		sl351x_clean_txq(dev, priv->txq + i, r);
+	}
+	writel(0, base_reg);
+
+	kfree(priv->txq->skb);
+	dma_free_coherent(toe->dev,
+		n_txq * sizeof(*priv->txq->ring) << priv->txq_order,
+		priv->txq->ring, priv->txq_dma_base);
+}
+
+static int sl351x_setup_rxq(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	NONTOE_QHDR_T __iomem *qhdr = toe->iomem + TOE_DEFAULT_Q_HDR_BASE(dev->dev_id);
+
+	priv->rxq_rwptr = &qhdr->word1;
+	priv->rxq_ring = dma_alloc_coherent(toe->dev,
+		sizeof(*priv->rxq_ring) << priv->rxq_order,
+		&priv->rxq_dma_base, GFP_KERNEL);
+	if (!priv->rxq_ring)
+		return -ENOMEM;
+
+	BUG_ON(priv->rxq_dma_base & ~NONTOE_QHDR0_BASE_MASK);
+	
+	writel(priv->rxq_dma_base | priv->rxq_order, &qhdr->word0);
+	writel(0, priv->rxq_rwptr);
+	return 0;
+}
+
+static void sl351x_cleanup_rxq(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+
+	NONTOE_QHDR_T __iomem *qhdr = toe->iomem + TOE_DEFAULT_Q_HDR_BASE(dev->dev_id);
+	void __iomem *dma_reg = &qhdr->word0;
+	void __iomem *ptr_reg = &qhdr->word1;
+	GMAC_RXDESC_T *rxd = priv->rxq_ring;
+	DMA_RWPTR_T rw;
+	unsigned int r, w;
+	unsigned int m = (1 <<priv->rxq_order) - 1;
+	struct page *page;
+	dma_addr_t dma;
+
+	rw.bits32 = readl(ptr_reg);
+	r = rw.bits.rptr;
+	w = rw.bits.wptr;
+	writew(r, ptr_reg + 2);
+
+	writel(0, dma_reg);
+
+	rmb();
+	while (r != w) {
+		dma = rxd[r].word2.buf_adr;
+		r++;
+		r &= m;
+
+		if (!dma)
+			continue;
+
+		page = pfn_to_page(dma_to_pfn(toe->dev, dma));
+		put_page(page);
+	}
+
+	dma_free_coherent(toe->dev, sizeof(*priv->rxq_ring) << priv->rxq_order,
+		priv->rxq_ring, priv->rxq_dma_base);
+}
+
+static unsigned int toe_fill_freeq(struct toe_private *toe, int reset)
+{
+	void __iomem *rwptr_reg = toe->iomem + GLOBAL_SWFQ_RWPTR_REG;
+
+	DMA_RWPTR_T rw;
+	unsigned int pn, epn;
+	unsigned int fpp_order = PAGE_SHIFT - toe->freeq_frag_order;
+	unsigned int frag_len = 1 << toe->freeq_frag_order;
+	unsigned int m_pn = (1 << (toe->freeq_order - fpp_order)) - 1;
+	struct page *page;
+	unsigned int count = 0;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&toe->freeq_lock, flags);
+
+	rw.bits32 = readl(rwptr_reg);
+	pn = (reset ? rw.bits.rptr : rw.bits.wptr) >> fpp_order;
+	epn = (rw.bits.rptr >> fpp_order) - 1;
+	epn &= m_pn;
+
+	while (pn != epn) {
+		page = toe->freeq_page_tab[pn];
+
+		if (unlikely(!page)) {
+			GMAC_RXDESC_T *freeq_entry;
+			dma_addr_t dma;
+
+			page = alloc_page(__GFP_COLD | GFP_ATOMIC);
+			if (unlikely(!page))
+				break;
+
+			dma = dma_map_page(toe->dev, page, 0, PAGE_SIZE,
+					   DMA_FROM_DEVICE);
+
+
+			if (unlikely(dma_mapping_error(toe->dev, dma) || !dma)) {
+				put_page(page);
+				break;
+			}
+
+			freeq_entry = toe->freeq_ring + (pn << fpp_order);
+			for (i = 1 << fpp_order; i > 0; --i) {
+				freeq_entry->word2.buf_adr = dma;
+				freeq_entry++;
+				dma += frag_len;
+			}
+
+
+			toe->freeq_page_tab[pn] = page;
+		}
+
+		if (unlikely(page_count(page) == 0)) {
+			pr_info(DRV_NAME ": lost page: page count 0\n");
+			toe->freeq_page_tab[pn] = NULL;
+			continue;
+		}
+
+		if (unlikely(page_count(page) > 1)) {
+			dma_addr_t dma;
+
+			/* Exit if still more than 64 buffers available */
+			if (((pn -epn) & m_pn) > (64 >> fpp_order))
+				break;
+			toe->freeq_replaced++;
+
+			/* Unmap and release page */
+			dma = toe->freeq_ring[pn << fpp_order].word2.buf_adr;
+			dma_unmap_page(toe->dev, dma, PAGE_SIZE, DMA_FROM_DEVICE);
+			put_page(toe->freeq_page_tab[pn]);
+			toe->freeq_page_tab[pn] = NULL;
+			continue;
+		}
+
+		for (i=0; i<(1<<fpp_order); i++) {
+			get_page(page);
+			count++;
+		}
+
+		pn++;
+		pn &= m_pn;
+	}
+
+	wmb();
+	writew(pn << fpp_order, rwptr_reg+2);
+
+	spin_unlock_irqrestore(&toe->freeq_lock, flags);
+	return count;
+}
+
+static int toe_setup_freeq(struct toe_private *toe)
+{
+	void __iomem *dma_reg = toe->iomem + GLOBAL_SW_FREEQ_BASE_SIZE_REG;
+	QUEUE_THRESHOLD_T qt;
+	DMA_SKB_SIZE_T skbsz;
+	unsigned int filled;
+	unsigned int len = 1 << toe->freeq_order;
+	unsigned int fpp_order = PAGE_SHIFT - toe->freeq_frag_order;
+	unsigned int pages = len >> fpp_order;
+
+	toe->freeq_ring = dma_alloc_coherent(toe->dev,
+		sizeof(*toe->freeq_ring) << toe->freeq_order,
+		&toe->freeq_dma_base, GFP_KERNEL);
+	if (!toe->freeq_ring)
+		return -ENOMEM;
+
+	BUG_ON(toe->freeq_dma_base & ~DMA_Q_BASE_MASK);
+
+	toe->freeq_page_tab = kzalloc(pages * sizeof(*toe->freeq_page_tab),
+							GFP_KERNEL);
+	if (!toe->freeq_page_tab)
+		goto err_freeq;
+
+	filled = toe_fill_freeq(toe, 1);
+	if (!filled)
+		goto err_freeq;
+
+	qt.bits32 = readl(toe->iomem + GLOBAL_QUEUE_THRESHOLD_REG);
+	qt.bits.swfq_empty = 32;
+	writel(qt.bits32, toe->iomem + GLOBAL_QUEUE_THRESHOLD_REG);
+
+	skbsz.bits.sw_skb_size = 1 << toe->freeq_frag_order;
+	writel(skbsz.bits32, toe->iomem + GLOBAL_DMA_SKB_SIZE_REG);
+	writel(toe->freeq_dma_base | toe->freeq_order, dma_reg);
+	return 0;
+
+err_freeq:
+	dma_free_coherent(toe->dev,
+		sizeof(*toe->freeq_ring) << toe->freeq_order,
+		toe->freeq_ring, toe->freeq_dma_base);
+	toe->freeq_ring = NULL;
+	return -ENOMEM;
+}
+
+static void toe_cleanup_freeq(struct toe_private *toe)
+{
+	void __iomem *dma_reg = toe->iomem + GLOBAL_SW_FREEQ_BASE_SIZE_REG;
+	void __iomem *ptr_reg = toe->iomem + GLOBAL_SWFQ_RWPTR_REG;
+
+	unsigned int len = 1 << toe->freeq_order;
+	unsigned int fpp_order = PAGE_SHIFT - toe->freeq_frag_order;
+	unsigned int pages = len >> fpp_order;
+	struct page *page;
+	dma_addr_t dma;
+	unsigned int pn;
+
+	writew(readw(ptr_reg), ptr_reg + 2);
+	writel(0, dma_reg);
+
+	for (pn = 0; pn < pages; pn++) {
+		page = toe->freeq_page_tab[pn];
+		if (!page)
+			continue;
+
+		dma = toe->freeq_ring[pn << fpp_order].word2.buf_adr;
+		dma_unmap_page(toe->dev, dma, PAGE_SIZE, DMA_FROM_DEVICE);
+
+		while (page_count(page) > 0)
+			put_page(page);
+	}
+
+	kfree(toe->freeq_page_tab);
+
+	dma_free_coherent(toe->dev,
+		sizeof(*toe->freeq_ring) << toe->freeq_order,
+		toe->freeq_ring, toe->freeq_dma_base);
+}
+
+static int toe_resize_freeq(struct toe_private *toe, int changing_dev_id)
+{
+	void __iomem *irqen_reg = toe->iomem + GLOBAL_INTERRUPT_ENABLE_4_REG;
+	struct sl351x_private *priv;
+	struct net_device *other = toe->netdev[1 - changing_dev_id];
+	unsigned new_size = 0;
+	unsigned new_order;
+	int err;
+	unsigned long flags;
+	unsigned en;
+
+	if (other && netif_running(other))
+		return -EBUSY;
+
+	if (toe->netdev[0]) {
+		priv = netdev_priv(toe->netdev[0]);
+		new_size  = 1 << (priv->rxq_order + 1);
+	}
+
+	if (toe->netdev[1]) {
+		priv = netdev_priv(toe->netdev[1]);
+		new_size  += 1 << (priv->rxq_order + 1);
+	}
+
+	new_order = min(15, ilog2(new_size - 1) + 1);
+	if (toe->freeq_order == new_order)
+		return 0;
+
+	spin_lock_irqsave(&toe->irq_lock, flags);
+	en = readl(irqen_reg);
+	en &= ~SWFQ_EMPTY_INT_BIT;
+	writel(en, irqen_reg);
+
+	if (toe->freeq_ring)
+		toe_cleanup_freeq(toe);
+
+	toe->freeq_order = new_order;
+	err = toe_setup_freeq(toe);
+
+	en |= SWFQ_EMPTY_INT_BIT;
+	writel(en, irqen_reg);
+	spin_unlock_irqrestore(&toe->irq_lock, flags);
+
+	return err;
+}
+
+static void sl351x_tx_irq_enable(struct net_device *dev, unsigned txq, int en)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned val, mask;
+
+	mask = GMAC0_IRQ0_TXQ0_INTS << (6 * dev->dev_id + txq);
+
+	if (en)
+		writel(mask, toe->iomem + GLOBAL_INTERRUPT_STATUS_0_REG);
+
+	val = readl(toe->iomem + GLOBAL_INTERRUPT_ENABLE_0_REG);
+	val = en ? val | mask : val & ~mask;
+	writel(val, toe->iomem + GLOBAL_INTERRUPT_ENABLE_0_REG);
+}
+
+
+static void sl351x_tx_irq(struct net_device *dev, unsigned txq_num)
+{
+	struct netdev_queue *ntxq = netdev_get_tx_queue(dev, txq_num);
+
+	sl351x_tx_irq_enable(dev, txq_num, 0);
+	netif_tx_wake_queue(ntxq);
+}
+
+static int sl351x_map_tx_bufs(struct net_device *dev, struct sk_buff *skb,
+			    struct sl351x_txq *txq, unsigned short *desc)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	struct skb_shared_info *skb_si =  skb_shinfo(skb);
+	skb_frag_t *skb_frag;
+	short frag, last_frag = skb_si->nr_frags - 1;
+	unsigned short m = (1 << priv->txq_order) -1;
+	unsigned short w = *desc;
+	unsigned word1, word3, buflen;
+	dma_addr_t dma;
+	void *buffer;
+	unsigned short mtu;
+	GMAC_TXDESC_T *txd;
+
+	mtu  = ETH_HLEN;
+	mtu += dev->mtu;
+	if (skb->protocol == htons(ETH_P_8021Q))
+		mtu += VLAN_HLEN;
+
+	word1 = skb->len;
+	word3 = SOF_BIT;
+		
+	if (word1 > mtu) {
+		word1 |= TSS_MTU_ENABLE_BIT;
+		word3 += mtu;
+	}
+
+	if (skb->ip_summed != CHECKSUM_NONE) {
+		int tcp = 0;
+		if (skb->protocol == htons(ETH_P_IP)) {
+			word1 |= TSS_IP_CHKSUM_BIT;
+			tcp = ip_hdr(skb)->protocol == IPPROTO_TCP;
+		} else { /* IPv6 */
+			word1 |= TSS_IPV6_ENABLE_BIT;
+			tcp = ipv6_hdr(skb)->nexthdr == IPPROTO_TCP;
+		}
+
+		word1 |= tcp ? TSS_TCP_CHKSUM_BIT : TSS_UDP_CHKSUM_BIT;
+	}
+
+	frag = -1;
+	while (frag <= last_frag) {
+		if (frag == -1) {
+			buffer = skb->data;
+			buflen = skb_headlen(skb);
+		} else {
+			skb_frag = skb_si->frags + frag;
+			buffer = page_address(skb_frag_page(skb_frag)) +
+				 skb_frag->page_offset;
+			buflen = skb_frag->size;
+		}
+
+		if (frag == last_frag) {
+			word3 |= EOF_BIT;
+			txq->skb[w] = skb;
+		}
+
+		dma = dma_map_single(toe->dev, buffer, buflen,
+					DMA_TO_DEVICE);
+		if (dma_mapping_error(toe->dev, dma) ||
+			!(dma & PAGE_MASK))
+			goto map_error;
+
+		txd = txq->ring + w;
+		txd->word0.bits32 = buflen;
+		txd->word1.bits32 = word1;
+		txd->word2.buf_adr = dma;
+		txd->word3.bits32 = word3;
+
+		word3 &= MTU_SIZE_BIT_MASK;
+		w++;
+		w &= m;
+		frag++;
+	}
+
+	*desc = w;
+	return 0;
+
+map_error:
+	while (w != *desc) {
+		w--;
+		w &= m;
+
+		dma_unmap_single(toe->dev, txq->ring[w].word2.buf_adr,
+			txq->ring[w].word0.bits.buffer_size, DMA_TO_DEVICE);
+	}
+	return ENOMEM;
+}
+
+static int sl351x_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+	void __iomem *ptr_reg;
+	struct sl351x_txq *txq;
+	struct netdev_queue *ntxq;
+	int txq_num, nfrags;
+	DMA_RWPTR_T rw;
+	unsigned short r, w, d;
+	unsigned short m = (1 << priv->txq_order) - 1;
+
+	SKB_FRAG_ASSERT(skb);
+
+	if (unlikely(skb->len >= 0x10000))
+		goto out_drop_free;
+
+	txq_num = skb_get_queue_mapping(skb);
+	ptr_reg = priv->dma_iomem + GMAC_SW_TX_QUEUE_PTR_REG(txq_num);
+	txq = &priv->txq[txq_num];
+	ntxq = netdev_get_tx_queue(dev, txq_num);
+	nfrags = skb_shinfo(skb)->nr_frags;
+
+	rw.bits32 = readl(ptr_reg);
+	r = rw.bits.rptr;
+	w = rw.bits.wptr;
+
+	d = txq->cptr - w - 1;
+	d &= m;
+
+	if (unlikely(d < nfrags+2))
+	{
+		sl351x_clean_txq(dev, txq, r);
+		d = txq->cptr - w - 1;
+		d &= m;
+
+		if (unlikely(d < nfrags+2)) {
+			netif_tx_stop_queue(ntxq);
+
+			d = txq->cptr + nfrags + 16;
+			d &= m;
+			txq->ring[d].word3.bits.eofie = 1;
+			sl351x_tx_irq_enable(dev, txq_num, 1);
+
+			u64_stats_update_begin(&priv->tx_stats_syncp);
+			dev->stats.tx_fifo_errors++;
+			u64_stats_update_end(&priv->tx_stats_syncp);
+			return NETDEV_TX_BUSY;
+		}
+	}
+
+	if (unlikely(sl351x_map_tx_bufs(dev, skb, txq, &w))) {
+		if (skb_linearize(skb))
+			goto out_drop;
+
+		if (unlikely(sl351x_map_tx_bufs(dev, skb, txq, &w)))
+			goto out_drop_free;
+
+		u64_stats_update_begin(&priv->tx_stats_syncp);
+		priv->tx_frags_linearized++;
+		u64_stats_update_end(&priv->tx_stats_syncp);
+	}
+
+	writew(w, ptr_reg+2);
+
+	sl351x_clean_txq(dev, txq, r);
+	return NETDEV_TX_OK;
+
+out_drop_free:
+	dev_kfree_skb(skb);
+out_drop:
+	u64_stats_update_begin(&priv->tx_stats_syncp);
+	priv->stats.tx_dropped++;
+	u64_stats_update_end(&priv->tx_stats_syncp);
+	return NETDEV_TX_OK;
+}
+
+static void sl351x_tx_timeout(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+	netif_err(priv, tx_err, dev, "Tx timeout\n");
+}
+
+static void sl351x_enable_irq(struct net_device *dev, int enable)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned long flags;
+	unsigned val, mask;
+
+	spin_lock_irqsave(&toe->irq_lock, flags);
+
+	mask = GMAC0_IRQ0_2 << (dev->dev_id * 2);
+	val = readl(toe->iomem + GLOBAL_INTERRUPT_ENABLE_0_REG);
+	val = enable ? (val | mask) : (val & ~mask);
+	writel(val, toe->iomem + GLOBAL_INTERRUPT_ENABLE_0_REG);
+
+	mask = DEFAULT_Q0_INT_BIT << dev->dev_id;
+	val = readl(toe->iomem + GLOBAL_INTERRUPT_ENABLE_1_REG);
+	val = enable ? (val | mask) : (val & ~mask);
+	writel(val, toe->iomem + GLOBAL_INTERRUPT_ENABLE_1_REG);
+
+	mask = GMAC0_IRQ4_8 << (dev->dev_id * 8);
+	val = readl(toe->iomem + GLOBAL_INTERRUPT_ENABLE_4_REG);
+	val = enable ? (val | mask) : (val & ~mask);
+	writel(val, toe->iomem + GLOBAL_INTERRUPT_ENABLE_4_REG);
+
+	spin_unlock_irqrestore(&toe->irq_lock, flags);
+}
+
+static void sl351x_enable_rx_irq(struct net_device *dev, int enable)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned long flags;
+	unsigned val, mask;
+
+	spin_lock_irqsave(&toe->irq_lock, flags);
+	mask = DEFAULT_Q0_INT_BIT << dev->dev_id;
+
+	val = readl(toe->iomem + GLOBAL_INTERRUPT_ENABLE_1_REG);
+	val = enable ? (val | mask) : (val & ~mask);
+	writel(val, toe->iomem + GLOBAL_INTERRUPT_ENABLE_1_REG);
+
+	spin_unlock_irqrestore(&toe->irq_lock, flags);
+}
+
+static unsigned sl351x_rx(struct net_device *dev, unsigned budget)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	void __iomem *ptr_reg = priv->rxq_rwptr;
+	struct sk_buff *skb = NULL;
+
+	DMA_RWPTR_T rw;
+	unsigned short r, w;
+	unsigned short m = (1 << priv->rxq_order) -1;
+	GMAC_RXDESC_T *rx = NULL;
+	struct page* page = NULL;
+	unsigned page_offs;
+	unsigned int frame_len, frag_len;
+	
+	GMAC_RXDESC_0_T word0;
+	GMAC_RXDESC_1_T word1;
+	dma_addr_t dma;
+	GMAC_RXDESC_3_T word3;
+
+	rw.bits32 = readl(ptr_reg);
+	/* Reset interrupt as all packages until here are taken into account */
+	writel(DEFAULT_Q0_INT_BIT << dev->dev_id,
+		toe->iomem + GLOBAL_INTERRUPT_STATUS_1_REG);
+	r = rw.bits.rptr;
+	w = rw.bits.wptr;
+	
+	while (budget && w != r) {
+		rx = priv->rxq_ring + r;
+		word0 = rx->word0;
+		word1 = rx->word1;
+		dma = rx->word2.buf_adr;
+		word3 = rx->word3;
+		
+		r++;
+		r &= m;
+
+		frag_len = word0.bits.buffer_size;
+		frame_len =word1.bits.byte_count;
+		skb = priv->napi.skb;
+
+		if (unlikely(!dma)) {
+			netif_err(priv, rx_err, dev, "rxq[%u]: HW BUG: zero DMA desc\n", r);
+			priv->stats.rx_dropped++;
+			if (unlikely(skb))
+				napi_free_frags(&priv->napi);
+			continue;
+		}
+
+		page = pfn_to_page(dma_to_pfn(toe->dev, dma));
+		page_offs = dma & ~PAGE_MASK;
+
+		if (word3.bits32 & SOF_BIT) {
+			unsigned rx_status = word0.bits.status;
+			unsigned rx_csum = word0.bits.chksum_status;
+
+			if (unlikely(skb)) {
+				priv->stats.rx_dropped++;
+				napi_free_frags(&priv->napi);
+			}
+
+			if (word0.bits.derr || word0.bits.perr ||
+    			    rx_status || frame_len < ETH_ZLEN ||
+    			    rx_csum >= RX_CHKSUM_IP_ERR_UNKNOWN) {
+				if (frame_len < ETH_ZLEN ||
+				    RX_ERROR_LENGTH(rx_status))
+					priv->stats.rx_length_errors++;
+				if (RX_ERROR_OVER(rx_status))
+					priv->stats.rx_over_errors++;
+				if (RX_ERROR_CRC(rx_status))
+					priv->stats.rx_crc_errors++;
+				if (RX_ERROR_FRAME(rx_status))
+					priv->stats.rx_frame_errors++;
+
+				priv->stats.rx_errors++;
+				priv->stats.rx_dropped++;
+				put_page(page);
+				continue;
+			}
+
+			skb = napi_get_frags(&priv->napi);
+			if (unlikely(!skb)) {
+				priv->stats.rx_dropped++;
+				put_page(page);
+				continue;
+			}
+
+			if (rx_csum == RX_CHKSUM_IP_UDP_TCP_OK)
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+			page_offs += NET_IP_ALIGN;
+			frag_len -= NET_IP_ALIGN;
+
+			priv->rx_stats[rx_status]++;
+			priv->rx_csum_stats[rx_csum]++;
+			priv->stats.rx_bytes += frame_len;
+			priv->stats.rx_packets++;
+
+		} else if (!skb) {
+			priv->stats.rx_dropped++;
+			put_page(page);
+			continue;
+		}
+
+		if (word3.bits32 & EOF_BIT)
+			frag_len = frame_len - skb->len;
+
+		if (frag_len == 0)
+			netif_err(priv, rx_err, dev, "Received fragment with len = 0");
+
+		skb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags,
+				   page, page_offs, frag_len);
+		skb->len += frag_len;
+		skb->data_len += frag_len;
+		skb->truesize += frag_len;
+
+		if (word3.bits32 & EOF_BIT) {
+			napi_gro_frags(&priv->napi);
+			--budget;
+		}
+	}
+
+	writew(r, ptr_reg);
+	return budget;
+}
+
+static int sl351x_napi_poll(struct napi_struct *napi, int budget)
+{
+	struct sl351x_private *priv = netdev_priv(napi->dev);
+	struct toe_private *toe = priv->toe;
+	unsigned rx;
+	unsigned freeq_threshold = 1 << (toe->freeq_order - 1);
+
+	u64_stats_update_begin(&priv->rx_stats_syncp);
+	
+	rx = budget - sl351x_rx(napi->dev, budget);
+
+	if (rx == 0) {
+		napi_gro_flush(napi, false);
+		__napi_complete(napi);
+		sl351x_enable_rx_irq(napi->dev, 1);
+		++priv->rx_napi_exits;
+	}
+
+	priv->freeq_refill += rx;
+	if (priv->freeq_refill > freeq_threshold) {
+		priv->freeq_refill -= freeq_threshold;
+		toe_fill_freeq(toe, 0);
+	}
+
+	u64_stats_update_end(&priv->rx_stats_syncp);
+	return rx;
+}
+
+static void sl351x_update_hw_stats(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned long flags;
+	unsigned int rx_discards, rx_mcast, rx_bcast;
+
+	spin_lock_irqsave(&toe->irq_lock, flags);
+	u64_stats_update_begin(&priv->ir_stats_syncp);
+
+	priv->hw_stats[0] += rx_discards = readl(priv->ctl_iomem + GMAC_IN_DISCARDS);
+	priv->hw_stats[1] += readl(priv->ctl_iomem + GMAC_IN_ERRORS);
+	priv->hw_stats[2] += rx_mcast = readl(priv->ctl_iomem + GMAC_IN_MCAST);
+	priv->hw_stats[3] += rx_bcast = readl(priv->ctl_iomem + GMAC_IN_BCAST);
+	priv->hw_stats[4] += readl(priv->ctl_iomem + GMAC_IN_MAC1);
+	priv->hw_stats[5] += readl(priv->ctl_iomem + GMAC_IN_MAC2);
+
+	priv->stats.rx_missed_errors += rx_discards;
+	priv->stats.multicast += rx_mcast;
+	priv->stats.multicast += rx_bcast;
+
+	writel(GMAC0_MIB_INT_BIT << (dev->dev_id * 8),
+		toe->iomem + GLOBAL_INTERRUPT_STATUS_4_REG);
+
+	u64_stats_update_end(&priv->ir_stats_syncp);
+	spin_unlock_irqrestore(&toe->irq_lock, flags);
+}
+
+static inline unsigned sl351x_get_intr_flags(struct net_device *dev, int i)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	void __iomem *irqif_reg, *irqen_reg;
+	unsigned offs, val;
+
+	offs = i * (GLOBAL_INTERRUPT_STATUS_1_REG - GLOBAL_INTERRUPT_STATUS_0_REG);
+
+	irqif_reg = toe->iomem + GLOBAL_INTERRUPT_STATUS_0_REG + offs;
+	irqen_reg = toe->iomem + GLOBAL_INTERRUPT_ENABLE_0_REG + offs;
+
+	val = readl(irqif_reg) & readl(irqen_reg);
+	return val;
+}
+
+enum hrtimer_restart sl351x_coalesce_delay_expired( struct hrtimer *timer )
+{
+	struct sl351x_private *priv = container_of(timer, struct sl351x_private, rx_coalesce_timer);
+
+	napi_schedule(&priv->napi);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t sl351x_irq(int irq, void *data)
+{
+	struct net_device *dev = data;
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned val, orr = 0;
+
+	orr |= val = sl351x_get_intr_flags(dev, 0);
+
+	if (unlikely(val & (GMAC0_IRQ0_2 << (dev->dev_id * 2)))) {
+		netif_err(priv, rx_err, dev, "hw failure/sw bug");
+		sl351x_enable_irq(dev, 0);
+		return IRQ_HANDLED;
+	}
+
+	if (val & (GMAC0_IRQ0_TXQ0_INTS << (dev->dev_id * 6)))
+		sl351x_tx_irq(dev, 0);
+
+	orr |= val = sl351x_get_intr_flags(dev, 1);
+
+	if (val & (DEFAULT_Q0_INT_BIT << dev->dev_id)) {
+
+		sl351x_enable_rx_irq(dev, 0);
+
+		if (!priv->rx_coalesce_nsecs)
+			napi_schedule(&priv->napi);
+		else {
+			ktime_t ktime;
+			ktime = ktime_set(0, priv->rx_coalesce_nsecs);
+			hrtimer_start(&priv->rx_coalesce_timer, ktime, HRTIMER_MODE_REL);
+		}
+	}
+
+	orr |= val = sl351x_get_intr_flags(dev, 4);
+
+	if (unlikely(val & (GMAC0_MIB_INT_BIT << (dev->dev_id * 8))))
+		sl351x_update_hw_stats(dev);
+
+	if (unlikely(val & (GMAC0_RX_OVERRUN_INT_BIT << (dev->dev_id * 8)))) {
+		writel(GMAC0_RXDERR_INT_BIT << (dev->dev_id * 8),
+			toe->iomem + GLOBAL_INTERRUPT_STATUS_4_REG);
+
+		spin_lock(&toe->irq_lock);
+		u64_stats_update_begin(&priv->ir_stats_syncp);
+		++priv->stats.rx_fifo_errors;
+		u64_stats_update_end(&priv->ir_stats_syncp);
+		spin_unlock(&toe->irq_lock);
+	}
+
+	return orr ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static void sl351x_start_dma(struct sl351x_private *priv)
+{
+	void __iomem *dma_ctrl_reg = priv->dma_iomem + GMAC_DMA_CTRL_REG;
+	GMAC_DMA_CTRL_T	dma_ctrl;
+
+	dma_ctrl.bits32 = readl(dma_ctrl_reg);
+	dma_ctrl.bits.rd_enable = 1;
+	dma_ctrl.bits.td_enable = 1;
+	dma_ctrl.bits.loopback = 0;
+	dma_ctrl.bits.drop_small_ack = 0;
+	dma_ctrl.bits.rd_insert_bytes = NET_IP_ALIGN;
+	dma_ctrl.bits.rd_prot = HPROT_DATA_CACHE | HPROT_PRIVILIGED;
+	dma_ctrl.bits.rd_burst_size = HBURST_INCR8;
+	dma_ctrl.bits.rd_bus = HSIZE_8;
+	dma_ctrl.bits.td_prot = HPROT_DATA_CACHE;
+	dma_ctrl.bits.td_burst_size = HBURST_INCR8;
+	dma_ctrl.bits.td_bus = HSIZE_8;
+
+	writel(dma_ctrl.bits32, dma_ctrl_reg);
+}
+
+static void sl351x_stop_dma(struct sl351x_private *priv)
+{
+	void __iomem *dma_ctrl_reg = priv->dma_iomem + GMAC_DMA_CTRL_REG;
+	GMAC_DMA_CTRL_T	dma_ctrl;
+
+	dma_ctrl.bits32 = readl(dma_ctrl_reg);
+	dma_ctrl.bits.rd_enable = 0;
+	dma_ctrl.bits.td_enable = 0;
+	writel(dma_ctrl.bits32, dma_ctrl_reg);
+}
+
+static int sl351x_open(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	int err;
+
+	err = request_irq(dev->irq, sl351x_irq,
+		IRQF_SHARED, dev->name, dev);
+	if (unlikely(err))
+		return err;
+
+ 	phy_start(dev->phydev);
+
+	err = toe_resize_freeq(priv->toe, dev->dev_id);
+	if (unlikely(err))
+		goto err_stop_phy;
+
+	err = sl351x_setup_rxq(dev);
+	if (unlikely(err))
+		goto err_stop_phy;
+
+	err = sl351x_setup_txqs(dev);
+	if (unlikely(err))
+		goto err_clean_rxq;
+
+	napi_enable(&priv->napi);
+	sl351x_start_dma(priv);
+	sl351x_enable_irq(dev, 1);
+	sl351x_set_txrx(dev, 1);
+	netif_tx_start_all_queues(dev);
+
+	hrtimer_init(&priv->rx_coalesce_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	priv->rx_coalesce_timer.function = &sl351x_coalesce_delay_expired;
+	return 0;
+
+err_clean_rxq:
+	sl351x_cleanup_rxq(dev);
+err_stop_phy:
+	phy_stop(dev->phydev);
+	free_irq(dev->irq, dev);
+	return err;
+}
+
+static int sl351x_stop(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+
+	hrtimer_cancel(&priv->rx_coalesce_timer);
+	netif_tx_stop_all_queues(dev);
+	sl351x_set_txrx(dev, 0);
+	sl351x_stop_dma(priv);
+	napi_disable(&priv->napi);
+
+	sl351x_enable_irq(dev, 0);
+	sl351x_cleanup_rxq(dev);
+	sl351x_cleanup_txqs(dev);
+
+	phy_stop(dev->phydev);
+
+	free_irq(dev->irq, dev);
+	sl351x_update_hw_stats(dev);
+	return 0;
+}
+
+static void sl351x_set_rx_mode(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct netdev_hw_addr *ha;
+	__u32 mc_filter[2];
+	unsigned bit_nr;
+	GMAC_RX_FLTR_T filter = { .bits = {
+		.broadcast = 1,
+		.multicast = 1,
+		.unicast = 1,
+	} };
+
+	mc_filter[1] = mc_filter[0] = 0;
+
+	if (dev->flags & IFF_PROMISC) {
+		filter.bits.error = 1;
+		filter.bits.promiscuous = 1;
+	} else if (!(dev->flags & IFF_ALLMULTI)) {
+		mc_filter[1] = mc_filter[0] = 0;
+		netdev_for_each_mc_addr(ha, dev) {
+			bit_nr = ~crc32_le(~0, ha->addr, ETH_ALEN) & 0x3f;
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 0x1f);
+		}
+	}
+
+	writel(mc_filter[0], priv->ctl_iomem + GMAC_MCAST_FIL0);
+	writel(mc_filter[1], priv->ctl_iomem + GMAC_MCAST_FIL1);
+	writel(filter.bits32, priv->ctl_iomem + GMAC_RX_FLTR);
+}
+
+static void __sl351x_set_mac_address(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	__le32 addr[3];
+
+	memset(addr, 0, sizeof(addr));
+	memcpy(addr, dev->dev_addr, ETH_ALEN);
+
+	writel(le32_to_cpu(addr[0]), priv->ctl_iomem + GMAC_STA_ADD0);
+	writel(le32_to_cpu(addr[1]), priv->ctl_iomem + GMAC_STA_ADD1);
+	writel(le32_to_cpu(addr[2]), priv->ctl_iomem + GMAC_STA_ADD2);
+}
+
+static int sl351x_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sa = addr;
+
+	memcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);
+	__sl351x_set_mac_address(dev);
+
+	return 0;
+}
+
+static void sl351x_clear_hw_stats(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+	readl(priv->ctl_iomem + GMAC_IN_DISCARDS);
+	readl(priv->ctl_iomem + GMAC_IN_ERRORS);
+	readl(priv->ctl_iomem + GMAC_IN_MCAST);
+	readl(priv->ctl_iomem + GMAC_IN_BCAST);
+	readl(priv->ctl_iomem + GMAC_IN_MAC1);
+	readl(priv->ctl_iomem + GMAC_IN_MAC2);
+}
+
+static struct rtnl_link_stats64 *sl351x_get_stats64(struct net_device *dev,
+	struct rtnl_link_stats64 *storage)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	unsigned int start;
+
+	sl351x_update_hw_stats(dev);
+
+	/* racing with RX NAPI */
+	do {
+		start = u64_stats_fetch_begin(&priv->rx_stats_syncp);
+
+		storage->rx_packets = priv->stats.rx_packets;
+		storage->rx_bytes = priv->stats.rx_bytes;
+		storage->rx_errors = priv->stats.rx_errors;
+		storage->rx_dropped = priv->stats.rx_dropped;
+
+		storage->rx_length_errors = priv->stats.rx_length_errors;
+		storage->rx_over_errors = priv->stats.rx_over_errors;
+		storage->rx_crc_errors = priv->stats.rx_crc_errors;
+		storage->rx_frame_errors = priv->stats.rx_frame_errors;
+
+	} while (u64_stats_fetch_retry(&priv->rx_stats_syncp, start));
+
+	/* racing with MIB and TX completion interrupts */
+	do {
+		start = u64_stats_fetch_begin(&priv->ir_stats_syncp);
+
+		storage->tx_errors = priv->stats.tx_errors;
+		storage->tx_packets = priv->stats.tx_packets;
+		storage->tx_bytes = priv->stats.tx_bytes;
+
+		storage->multicast = priv->stats.multicast;
+		storage->rx_missed_errors = priv->stats.rx_missed_errors;
+		storage->rx_fifo_errors = priv->stats.rx_fifo_errors;
+
+	} while (u64_stats_fetch_retry(&priv->ir_stats_syncp, start));
+
+	/* racing with hard_start_xmit */
+	do {
+		start = u64_stats_fetch_begin(&priv->tx_stats_syncp);
+
+		storage->tx_dropped = priv->stats.tx_dropped;
+
+	} while (u64_stats_fetch_retry(&priv->tx_stats_syncp, start));
+
+	storage->rx_dropped += storage->rx_missed_errors;
+
+	return storage;
+}
+
+static int sl351x_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	int max_len = sl351x_pick_rx_max_len(new_mtu);
+	unsigned long flags;
+	u32 reg;
+
+	if (max_len < 0)
+		return -EINVAL;
+
+	sl351x_set_txrx(dev, 0);
+	dev->mtu = new_mtu;
+
+	spin_lock_irqsave(&priv->config_lock, flags);
+	reg = readl(priv->ctl_iomem + GMAC_CONFIG0);
+	reg &= ~(CONFIG0_MAXLEN_MASK);
+	reg |= max_len << CONFIG0_MAXLEN_SHIFT;
+	writel(reg, priv->ctl_iomem + GMAC_CONFIG0);
+	spin_unlock_irqrestore(&priv->config_lock, flags);
+
+	netdev_update_features(dev);
+	sl351x_set_txrx(dev, 1);
+	return 0;
+}
+
+static netdev_features_t sl351x_fix_features(struct net_device *dev, netdev_features_t features)
+{
+	if (dev->mtu + ETH_HLEN + VLAN_HLEN > MTU_SIZE_BIT_MASK)
+		features &= ~GMAC_OFFLOAD_FEATURES;
+
+	return features;
+}
+
+static int sl351x_set_features(struct net_device *dev, netdev_features_t features)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	int enable = features & NETIF_F_RXCSUM;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&priv->config_lock, flags);
+	reg = readl(priv->ctl_iomem + GMAC_CONFIG0);
+	reg = enable ? reg | CONFIG0_RX_CHKSUM : reg & ~CONFIG0_RX_CHKSUM;
+	writel(reg, priv->ctl_iomem + GMAC_CONFIG0);
+	spin_unlock_irqrestore(&priv->config_lock, flags);
+	return 0;
+}
+
+static int sl351x_get_sset_count(struct net_device *dev, int sset)
+{
+	return sset == ETH_SS_STATS ? GMAC_STATS_NUM : 0;
+}
+
+static void sl351x_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	if (stringset != ETH_SS_STATS)
+		return;
+
+	memcpy(data, sl351x_stats_strings, sizeof(sl351x_stats_strings));
+}
+
+static void sl351x_get_ethtool_stats(struct net_device *dev,
+	struct ethtool_stats *estats, u64 *values)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	unsigned int start;
+	u64 *p;
+	int i;
+
+	sl351x_update_hw_stats(dev);
+
+	/* racing with MIB interrupt */
+	do {
+		p = values;
+		start = u64_stats_fetch_begin(&priv->ir_stats_syncp);
+
+		for (i = 0; i < RX_STATS_NUM; ++i)
+			*p++ = priv->hw_stats[i];
+
+	} while (u64_stats_fetch_retry(&priv->ir_stats_syncp, start));
+	values = p;
+
+	/* racing with RX NAPI */
+	do {
+		p = values;
+		start = u64_stats_fetch_begin(&priv->rx_stats_syncp);
+
+		for (i = 0; i < RX_STATUS_NUM; ++i)
+			*p++ = priv->rx_stats[i];
+		for (i = 0; i < RX_CHKSUM_NUM; ++i)
+			*p++ = priv->rx_csum_stats[i];
+		*p++ = priv->rx_napi_exits;
+
+	} while (u64_stats_fetch_retry(&priv->rx_stats_syncp, start));
+	values = p;
+
+	/* racing with TX start_xmit */
+	do {
+		p = values;
+		start = u64_stats_fetch_begin(&priv->tx_stats_syncp);
+
+		for (i = 0; i < TX_MAX_FRAGS; ++i) {
+			*values++ = priv->tx_frag_stats[i];
+			priv->tx_frag_stats[i] = 0;
+		}
+		*values++ = priv->tx_frags_linearized;
+		*values++ = priv->tx_hw_csummed;
+		*values++ = toe->freeq_replaced;
+
+	} while (u64_stats_fetch_retry(&priv->tx_stats_syncp, start));
+}
+
+static int sl351x_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	if (!dev->phydev)
+		return -ENXIO;
+	return phy_ethtool_gset(dev->phydev, cmd);
+}
+
+static int sl351x_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	if (!dev->phydev)
+		return -ENXIO;
+	return phy_ethtool_sset(dev->phydev, cmd);
+}
+
+static int sl351x_nway_reset(struct net_device *dev)
+{
+	if (!dev->phydev)
+		return -ENXIO;
+	return phy_start_aneg(dev->phydev);
+}
+
+static void sl351x_get_pauseparam(struct net_device *dev,
+	struct ethtool_pauseparam *pparam)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	GMAC_CONFIG0_T config0;
+
+	config0.bits32 = readl(priv->ctl_iomem + GMAC_CONFIG0);
+	pparam->rx_pause = config0.bits.rx_fc_en;
+	pparam->tx_pause = config0.bits.tx_fc_en;
+	pparam->autoneg = true;
+}
+
+static void sl351x_get_ringparam(struct net_device *dev,
+	struct ethtool_ringparam *rp)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	GMAC_CONFIG0_T config0;
+
+	config0.bits32 = readl(priv->ctl_iomem + GMAC_CONFIG0);
+
+	rp->rx_max_pending = 1 << 15;
+	rp->rx_mini_max_pending = 0;
+	rp->rx_jumbo_max_pending = 0;
+	rp->tx_max_pending = 1 << 15;
+
+	rp->rx_pending = 1 << priv->rxq_order;
+	rp->rx_mini_pending = 0;
+	rp->rx_jumbo_pending = 0;
+	rp->tx_pending = 1 << priv->txq_order;
+}
+
+static int toe_resize_freeq(struct toe_private *toe, int changing_dev_id);
+
+static int sl351x_set_ringparam(struct net_device *dev,
+	struct ethtool_ringparam *rp)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	struct toe_private *toe = priv->toe;
+	int err = 0;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	if (rp->rx_pending) {
+		priv->rxq_order = min(15, ilog2(rp->rx_pending - 1) + 1);
+		err = toe_resize_freeq(toe, dev->dev_id);
+	}
+
+	if (rp->tx_pending)
+	{
+		priv->txq_order = min(15, ilog2(rp->tx_pending - 1) + 1);
+		priv->irq_every_tx_packets = 1 << (priv->txq_order - 2);
+	}
+
+	return err;
+}
+
+static int sl351x_get_coalesce(struct net_device *dev,
+	struct ethtool_coalesce *ecmd)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+	ecmd->rx_max_coalesced_frames = 1;
+	ecmd->tx_max_coalesced_frames = priv->irq_every_tx_packets;
+	ecmd->rx_coalesce_usecs = priv->rx_coalesce_nsecs/1000;
+	return 0;
+}
+
+static int sl351x_set_coalesce(struct net_device *dev,
+	struct ethtool_coalesce *ecmd)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+
+	if (ecmd->tx_max_coalesced_frames < 1)
+		return -EINVAL;
+	if (ecmd->tx_max_coalesced_frames >= 1 << priv->txq_order)
+		return -EINVAL;
+
+	priv->irq_every_tx_packets = ecmd->tx_max_coalesced_frames;
+	priv->rx_coalesce_nsecs = ecmd->rx_coalesce_usecs * 1000;
+	return 0;
+}
+
+static u32 sl351x_get_msglevel(struct net_device *dev)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	return priv->msg_enable;
+}
+
+static void sl351x_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct sl351x_private *priv = netdev_priv(dev);
+	priv->msg_enable = level;
+}
+
+static void sl351x_get_drvinfo(struct net_device *dev,
+	struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver,  DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, dev->dev_id ? "1" : "0");
+}
+
+static const struct net_device_ops sl351x_ops = {
+	.ndo_init		= sl351x_hw_init,
+	.ndo_uninit		= sl351x_hw_uninit,
+	.ndo_open		= sl351x_open,
+	.ndo_stop		= sl351x_stop,
+	.ndo_start_xmit		= sl351x_start_xmit,
+	.ndo_tx_timeout		= sl351x_tx_timeout,
+	.ndo_set_rx_mode	= sl351x_set_rx_mode,
+	.ndo_set_mac_address	= sl351x_set_mac_address,
+	.ndo_get_stats64	= sl351x_get_stats64,
+	.ndo_change_mtu		= sl351x_change_mtu,
+	.ndo_fix_features	= sl351x_fix_features,
+	.ndo_set_features	= sl351x_set_features,
+};
+
+static const struct ethtool_ops sl351x_ethtool_ops = {
+	.get_sset_count	= sl351x_get_sset_count,
+	.get_strings	= sl351x_get_strings,
+	.get_ethtool_stats = sl351x_get_ethtool_stats,
+	.get_settings	= sl351x_get_settings,
+	.set_settings	= sl351x_set_settings,
+	.get_link	= ethtool_op_get_link,
+	.nway_reset	= sl351x_nway_reset,
+	.get_pauseparam	= sl351x_get_pauseparam,
+	.get_ringparam	= sl351x_get_ringparam,
+	.set_ringparam	= sl351x_set_ringparam,
+	.get_coalesce	= sl351x_get_coalesce,
+	.set_coalesce	= sl351x_set_coalesce,
+	.get_msglevel	= sl351x_get_msglevel,
+	.set_msglevel	= sl351x_set_msglevel,
+	.get_drvinfo	= sl351x_get_drvinfo,
+};
+
+static int sl351x_init_netdev(struct toe_private *toe, int num,
+	struct platform_device *pdev)
+{
+	struct sl351x_platform_data *pdata = pdev->dev.platform_data;
+	struct sl351x_private *priv;
+	struct net_device *dev;
+	int irq, err;
+
+	if (!pdata->bus_id[num])
+		return 0;
+
+	irq = platform_get_irq(pdev, num);
+	if (irq < 0) {
+		dev_err(toe->dev, "No IRQ for ethernet device #%d\n", num);
+		return irq;
+	}
+
+	dev = alloc_etherdev_mq(sizeof(*priv), TX_QUEUE_NUM);
+	if (!dev) {
+		dev_err(toe->dev, "Can't allocate ethernet device #%d\n", num);
+		return -ENOMEM;
+	}
+
+	priv = netdev_priv(dev);
+	priv->num = num;
+	priv->toe = toe;
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	priv->msg_enable = NETIF_MSG_DRV    |
+			   NETIF_MSG_LINK   |
+			   NETIF_MSG_PROBE  |
+			   NETIF_MSG_LINK   |
+			   NETIF_MSG_TIMER  |
+			   NETIF_MSG_LINK   |
+			   NETIF_MSG_IFUP   |
+			   NETIF_MSG_RX_ERR |
+			   NETIF_MSG_TX_ERR;
+
+	toe->netdev[num] = dev;
+	dev->dev_id = num;
+
+	priv->ctl_iomem = toe->iomem + TOE_GMAC_BASE(num);
+	priv->dma_iomem = toe->iomem + TOE_GMAC_DMA_BASE(num);
+	dev->irq = irq;
+
+	dev->netdev_ops = &sl351x_ops;
+	dev->ethtool_ops = &sl351x_ethtool_ops;
+
+	spin_lock_init(&priv->config_lock);
+	sl351x_clear_hw_stats(dev);
+
+	dev->hw_features = GMAC_OFFLOAD_FEATURES;
+	dev->features |= GMAC_OFFLOAD_FEATURES | NETIF_F_GRO;
+
+	priv->freeq_refill = 0;
+	netif_napi_add(dev, &priv->napi, sl351x_napi_poll, DEFAULT_NAPI_WEIGHT);
+
+	if (is_valid_ether_addr((void *)toe->mac_addr[num]))
+		memcpy(dev->dev_addr, toe->mac_addr[num], ETH_ALEN);
+	else
+		random_ether_addr(dev->dev_addr);
+	__sl351x_set_mac_address(dev);
+
+	err = sl351x_setup_phy(dev);
+	if (err) {
+		netif_err(priv, probe, dev, "PHY init failed: %d\n", err);
+		toe->netdev[num] = NULL;
+		free_netdev(dev);
+		return err;
+	}
+
+	err = register_netdev(dev);
+	if (err) {
+		toe->netdev[num] = NULL;
+		free_netdev(dev);
+		return err;
+	}
+
+	pr_info(DRV_NAME " %s: irq %d, dma base 0x%p, io base 0x%p\n",
+		dev->name, irq, priv->dma_iomem, priv->ctl_iomem);
+	return 0;
+}
+
+static irqreturn_t toe_irq_thread(int irq, void *data)
+{
+	struct toe_private *toe = data;
+	void __iomem *irq_en  = toe->iomem + GLOBAL_INTERRUPT_ENABLE_4_REG;
+	void __iomem *irq_st  = toe->iomem + GLOBAL_INTERRUPT_STATUS_4_REG;
+	unsigned long irqmask = SWFQ_EMPTY_INT_BIT;
+	unsigned long flags;
+
+	toe_fill_freeq(toe, 0);
+
+	/* Ack and enable interrupt */
+	spin_lock_irqsave(&toe->irq_lock, flags);
+	writel(irqmask, irq_st);
+	irqmask |= readl(irq_en);
+	writel(irqmask, irq_en);
+	spin_unlock_irqrestore(&toe->irq_lock, flags);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t toe_irq(int irq, void *data)
+{
+	struct toe_private *toe = data;
+	void __iomem *irq_en = toe->iomem + GLOBAL_INTERRUPT_ENABLE_4_REG;
+	void __iomem *irq_st = toe->iomem + GLOBAL_INTERRUPT_STATUS_4_REG;
+	unsigned long en;
+	irqreturn_t ret = IRQ_NONE;
+
+	spin_lock(&toe->irq_lock);
+
+	en = readl(irq_en);
+	if (readl(irq_st) & en & SWFQ_EMPTY_INT_BIT) {
+		en &= ~(SWFQ_EMPTY_INT_BIT |
+			GMAC0_RX_OVERRUN_INT_BIT |
+			GMAC1_RX_OVERRUN_INT_BIT);
+		writel(en, irq_en);
+		ret = IRQ_WAKE_THREAD;
+	}
+
+	spin_unlock(&toe->irq_lock);
+	return ret;
+}
+
+/*
+ * Interrupt config:
+ *
+ *	GMAC0 intr bits ------> int0 ----> eth0
+ *	GMAC1 intr bits ------> int1 ----> eth1
+ *	TOE intr -------------> int1 ----> eth1
+ *	Classification Intr --> int0 ----> eth0
+ *	Default Q0 -----------> int0 ----> eth0
+ *	Default Q1 -----------> int1 ----> eth1
+ *	FreeQ intr -----------> int1 ----> eth1
+ */
+static void toe_init_reg(void __iomem *toebase)
+{
+	writel(0, toebase + GLOBAL_INTERRUPT_ENABLE_0_REG);
+	writel(0, toebase + GLOBAL_INTERRUPT_ENABLE_1_REG);
+	writel(0, toebase + GLOBAL_INTERRUPT_ENABLE_2_REG);
+	writel(0, toebase + GLOBAL_INTERRUPT_ENABLE_3_REG);
+	writel(0, toebase + GLOBAL_INTERRUPT_ENABLE_4_REG);
+
+	writel(0xCCFC0FC0, toebase + GLOBAL_INTERRUPT_SELECT_0_REG);
+	writel(0x00F00002, toebase + GLOBAL_INTERRUPT_SELECT_1_REG);
+	writel(0xFFFFFFFF, toebase + GLOBAL_INTERRUPT_SELECT_2_REG);
+	writel(0xFFFFFFFF, toebase + GLOBAL_INTERRUPT_SELECT_3_REG);
+	writel(0xFF000003, toebase + GLOBAL_INTERRUPT_SELECT_4_REG);
+
+	/* edge-triggered interrupts packed to level-triggered one... */
+	writel(~0, toebase + GLOBAL_INTERRUPT_STATUS_0_REG);
+	writel(~0, toebase + GLOBAL_INTERRUPT_STATUS_1_REG);
+	writel(~0, toebase + GLOBAL_INTERRUPT_STATUS_2_REG);
+	writel(~0, toebase + GLOBAL_INTERRUPT_STATUS_3_REG);
+	writel(~0, toebase + GLOBAL_INTERRUPT_STATUS_4_REG);
+
+	writel(0, toebase + GLOBAL_SW_FREEQ_BASE_SIZE_REG);
+	writel(0, toebase + GLOBAL_HW_FREEQ_BASE_SIZE_REG);
+	writel(0, toebase + GLOBAL_SWFQ_RWPTR_REG);
+	writel(0, toebase + GLOBAL_HWFQ_RWPTR_REG);
+}
+
+static void toe_save_mac_addr(struct toe_private *toe,
+			struct platform_device *pdev)
+{
+	struct sl351x_platform_data *pdata = pdev->dev.platform_data;
+	void __iomem *ctl;
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (pdata->bus_id[i]) {
+			ctl = toe->iomem + TOE_GMAC_BASE(i);
+			toe->mac_addr[i][0] = cpu_to_le32(readl(ctl + GMAC_STA_ADD0));
+			toe->mac_addr[i][1] = cpu_to_le32(readl(ctl + GMAC_STA_ADD1));
+			toe->mac_addr[i][2] = cpu_to_le32(readl(ctl + GMAC_STA_ADD2));
+		}
+	}
+}
+
+static int toe_reset(struct toe_private *toe)
+{
+	unsigned int reg = 0, retry = 5;
+
+	reg = readl(IO_ADDRESS(GEMINI_GLOBAL_BASE) + GLOBAL_RESET);
+	reg |= RESET_GMAC1 | RESET_GMAC0;
+	writel(reg, IO_ADDRESS(GEMINI_GLOBAL_BASE) + GLOBAL_RESET);
+
+	do {
+		udelay(2);
+		reg = readl(toe->iomem + GLOBAL_TOE_VERSION_REG);
+		barrier();
+	} while (!reg && --retry);
+
+	return reg ? 0 : -EIO;
+}
+
+static int sl351x_remove(struct platform_device *pdev)
+{
+	struct toe_private *toe = platform_get_drvdata(pdev);
+	struct net_device *dev;
+	int i;
+
+	if (!toe)
+		return 0;
+
+	for (i = 0; i < 2; i++) {
+		dev = toe->netdev[i];
+		if (dev) {
+			unregister_netdev(dev);
+			if (dev->phydev)
+				phy_disconnect(dev->phydev);
+		}
+	}
+
+
+	if (toe->iomem)
+		toe_init_reg(toe->iomem);
+
+	if (toe->irq)
+		free_irq(toe->irq, toe);
+
+	toe_cleanup_freeq(toe);
+
+	if (toe->iomem)
+		iounmap(toe->iomem);
+
+	kfree(toe);
+	return 0;
+}
+
+static int sl351x_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct toe_private *toe;
+	int irq, i, retval;
+
+	if (!pdev->dev.platform_data)
+		return -EINVAL;
+
+	irq = platform_get_irq(pdev, 1);
+	if (irq < 0)
+		return irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "can't get device resources\n");
+		return -ENODEV;
+	}
+
+	toe = kzalloc(sizeof(*toe), GFP_KERNEL);
+	if (!toe)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, toe);
+	toe->dev = &pdev->dev;
+	toe->irq = irq;
+
+	toe->iomem = ioremap(res->start, resource_size(res));
+	if (!toe->iomem) {
+		dev_err(toe->dev, "ioremap failed\n");
+		sl351x_remove(pdev);
+		return -EIO;
+	}
+
+	toe_save_mac_addr(toe, pdev);
+	retval = toe_reset(toe);
+	if (retval < 0) {
+		sl351x_remove(pdev);
+		return retval;
+	}
+
+	pr_info(DRV_NAME " toe: irq %d, io base 0x%08x, version %d\n",
+		irq, res->start, retval);
+
+	spin_lock_init(&toe->irq_lock);
+	spin_lock_init(&toe->freeq_lock);
+
+	toe_init_reg(toe->iomem);
+
+	toe->freeq_frag_order = DEFAULT_RX_BUF_ORDER;
+	toe->freeq_order = ~0;
+
+	retval = request_threaded_irq(toe->irq, toe_irq,
+		toe_irq_thread, IRQF_SHARED, DRV_NAME " toe", toe);
+
+	if (retval) {
+		sl351x_remove(pdev);
+		return retval;
+	}
+
+	for (i=0; i<2; i++) {
+		retval = sl351x_init_netdev(toe, i, pdev);
+		if (retval) {
+			sl351x_remove(pdev);
+			return retval;
+		}
+	}
+
+	return 0;
+}
+
+static struct platform_driver sl351x_driver = {
+	.probe		= sl351x_probe,
+	.remove		= sl351x_remove,
+	.driver.name	= DRV_NAME,
+	.driver.owner	= THIS_MODULE,
+};
+
+static int __init sl351x_init(void)
+{
+#ifdef CONFIG_MDIO_GPIO_MODULE
+	request_module("mdio-gpio");
+#endif
+	return platform_driver_register(&sl351x_driver);
+}
+
+static void __exit sl351x_exit(void)
+{
+	platform_driver_unregister(&sl351x_driver);
+}
+
+module_init(sl351x_init);
+module_exit(sl351x_exit);
